<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>11-20</title>
</head>
<body>
<script>
    //第十一题链接https://leetcode-cn.com/problems/container-with-most-water/
    //再提交一次，双重循环暴力硬解居然超时了=）
    //
    /**
     * @param {number[]} height
     * @return {number}
     */
        //无脑全比较
    let maxArea = function (height) {
            let max = 0;
            for (let i = 0; i < height.length; i++) {
                for (let j = i + 1; j < height.length; j++) {
                    max = max > Math.min(height[i], height[j]) * (j - i) ? max : Math.min(height[i], height[j]) * (j - i)
                }
            }
            return max
        };
    //改进版
    let new_maxArea = function (height) {
        let left = 0,
            right = height.length - 1,
            max = 0;
        while (left < right) {
            max = Math.max(max, Math.min(height[left], height[right]) * (right - left));
            height[left] > height[right] ? right-- : left++
        }
        return max
    };

    //第十二题链接https://leetcode-cn.com/problems/integer-to-roman/
    //这题没啥好说的，就楞解。。
    /**
     * @param {number} num
     * @return {string}
     */
    let intToRoman = function (num) {
        let result = "",
            thousand = Math.floor(num / 1000),
            hundred = Math.floor(num / 100) - 10 * thousand,
            ten = Math.floor(num / 10) - 100 * thousand - 10 * hundred,
            left = num - 1000 * thousand - 100 * hundred - 10 * ten;
        switch (thousand) {
            case 0:
                break;
            case 1:
                result += "M";
                break;
            case 2:
                result += "MM";
                break;
            case 3:
                result += "MMM";
                break;
        }
        switch (hundred) {
            case 0:
                break;
            case 1:
                result += "C";
                break;
            case 2:
                result += "CC";
                break;
            case 3:
                result += "CCC";
                break;
            case 4:
                result += "CD";
                break;
            case 5:
                result += "D";
                break;
            case 6:
                result += "DC";
                break;
            case 7:
                result += "DCC";
                break;
            case 8:
                result += "DCCC";
                break;
            case 9:
                result += "CM";
                break;
        }
        switch (ten) {
            case 0:
                break;
            case 1:
                result += "X";
                break;
            case 2:
                result += "XX";
                break;
            case 3:
                result += "XXX";
                break;
            case 4:
                result += "XL";
                break;
            case 5:
                result += "L";
                break;
            case 6:
                result += "LX";
                break;
            case 7:
                result += "LXX";
                break;
            case 8:
                result += "LXXX";
                break;
            case 9:
                result += "XC";
                break;
        }
        switch (left) {
            case 0:
                break;
            case 1:
                result += "I";
                break;
            case 2:
                result += "II";
                break;
            case 3:
                result += "III";
                break;
            case 4:
                result += "IV";
                break;
            case 5:
                result += "V";
                break;
            case 6:
                result += "VI";
                break;
            case 7:
                result += "VII";
                break;
            case 8:
                result += "VIII";
                break;
            case 9:
                result += "IX";
                break;
        }
        return result
    };

    //第十三题链接https://leetcode-cn.com/problems/roman-to-integer/
    //没啥好说的，和上一题一样，硬来就完事了。。
    /**
     * @param {string} s
     * @return {number}
     */
    let romanToInt = function (s) {
        let result = 0, letter = s.split('');
        for (let i = 0; i < letter.length; i++) {
            switch (letter[i]) {
                case "M":
                    result += 1000;
                    break;
                case "D":
                    result += 500;
                    break;
                case "C":
                    if (letter[i + 1] !== 'M' && letter[i + 1] !== 'D') {
                        result += 100
                    } else {
                        result -= 100
                    }
                    break;
                case "L":
                    result += 50;
                    break;
                case "X":
                    if (letter[i + 1] !== 'C' && letter[i + 1] !== 'L') {
                        result += 10
                    } else {
                        result -= 10
                    }
                    break;
                case "V":
                    result += 5;
                    break;
                case "I":
                    if (letter[i + 1] !== 'V' && letter[i + 1] !== 'X') {
                        result += 1
                    } else {
                        result -= 1
                    }
                    break;
            }
        }
        return result
    };

    //第十四题链接https://leetcode-cn.com/problems/longest-common-prefix/
    //首先判断是否为空
    //先将第一个单词赋给一个临时变量，去和下一个单词进行比较，找出两个公共的最长前缀
    //再将比较后的公共前缀和下一个单词比较，依次循环，这样所有的单词比较完之后，剩余的即是所需答案
    /**
     * @param {string[]} strs
     * @return {string}
     */
    let longestCommonPrefix = function (strs) {
        if (strs.length === 0) return "";
        let answer = strs[0];
        for (let i = 1; i < strs.length; i++) {
            for (let j = 0; j < answer.length && j < strs[i].length; j++) {
                if (answer[j] !== strs[i][j])
                    break;
            }
            answer = answer.substr(0, j);
            if (answer === "")
                return answer;
        }
        return answer;
    };

    //第十五题链接https://leetcode-cn.com/problems/3sum/
    //首先最容易想到的肯定是三重循环，不过会超时
    //换一个思路，减少一重循环，先对数组进行排序
    //外层循环遍历数组，内层给定一左一右两个指针，和小于零则左指针右移，反正右指针左移
    /**
     * @param {number[]} nums
     * @return {number[][]}
     */
        //三重循环硬来（会超时）
    let threeSum = function (nums) {
            if (nums.length === 0) return [];
            let result = [], result_norepeat = [], flag = true, total_flag = true;
            for (let i = 0; i < nums.length; i++) {
                for (let j = i + 1; j < nums.length; j++) {
                    for (let k = j + 1; k < nums.length; k++) {
                        if (nums[i] + nums[j] + nums[k] === 0) {
                            result.push([nums[i], nums[j], nums[k]].sort())
                        }
                    }
                }
            }
            for (let i = 0; i < result.length; i++) {
                total_flag = true;
                for (let j = i + 1; j < result.length;) {
                    for (let index = 0; index < 3; index++) {
                        if (result[i][index] !== result[j][index]) {
                            flag = false;
                        }
                    }
                    if (flag) {
                        total_flag = false;
                        break;
                    } else {
                        flag = true;
                        j++
                    }
                }
                flag = true;
                if (total_flag) result_norepeat.push(result[i]);
            }
            return result_norepeat
        };
    //换一个思路，减少一层循环
    let new_threeSum = function (nums) {
        let result = [];
        if (nums.length < 3) return result;
        nums.sort((a, b) => a - b);
        for (let i = 0; i < nums.length; i++) {
            if (nums[i] > 0) break;//大于0可以结束了
            if (i > 0 && nums[i] === nums[i - 1]) continue;//重复的要跳过
            let left = i + 1,
                right = nums.length - 1;//设左右指针
            while (left < right) {
                let sum = nums[i] + nums[left] + nums[right];
                if (sum === 0) {
                    result.push([nums[i], nums[left], nums[right]]);
                    while (nums[left] === nums[left + 1]) left++;
                    while (nums[right] === nums[right - 1]) right--;//重复的要去掉否则可能会有重复结果的
                    left++;
                    right--
                } else {
                    sum < 0 ? left++ : right--
                }
            }
        }
        return result
    };

    //第十六题链接https://leetcode-cn.com/problems/3sum-closest/
    //整体思路和上一题类似,从和为0改成了找到一个差值最小,且唯一
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    let threeSumClosest = function (nums, target) {
        nums.sort((a, b) => a - b);
        let result = nums[0] + nums[1] + nums[2];
        for (let i = 0; i < nums.length; i++) {
            let left = i + 1,
                right = nums.length - 1;//设左右指针
            while (left < right) {
                let sum = nums[i] + nums[left] + nums[right];
                if (sum === target) return target;
                if (Math.abs(sum - target) < Math.abs(result - target)) {
                    result = sum;
                }
                sum < target ? left++ : right--
            }
        }
        return result
    };
</script>
</body>
</html>
