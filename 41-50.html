<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="data-structure.js"></script>
</head>
<body>
<script>
    //第四十一题链接https://leetcode-cn.com/problems/first-missing-positive/
    //先对数组进行排序，从第一个大于0的数开始
    //如果碰到相同的则跳过，不同的则判断是否存在
    //不存在则返回，即为所求
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var firstMissingPositive = function (nums) {
        nums = nums.sort((a, b) => a - b);
        let start = 1;
        for (let i = 0; i < nums.length; i++) {
            if (i >= 1 && nums[i] === nums[i - 1]) continue;
            if (nums[i] > 0) {
                if (nums[i] !== start) {
                    return start
                } else {
                    start++
                }
            }
        }
        return start
    };

    //第四十二题链接https://leetcode-cn.com/problems/trapping-rain-water/
    //第一遍循环，获取能存的水量
    //再循环一边计算实际存的水量
    /**
     * @param {number[]} height
     * @return {number}
     */
    var trap = function (height) {
        let result = 0,
            length = height.length,
            leftMax = new Array(length).fill(0),
            rightMax = new Array(length).fill(0);
        if (length === 0) return 0;
        leftMax[0] = height[0];
        rightMax[length - 1] = height[length - 1];
        for (let i = 1; i < length; i++) {
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);
            rightMax[length - i - 1] = Math.max(rightMax[length - i], height[length - i - 1]);
        }
        for (let i = 0; i < length; i++) {
            result += Math.min(leftMax[i], rightMax[i]) - height[i]
        }
        return result
    };

    //第四十三题链接https://leetcode-cn.com/problems/multiply-strings/
    //这题思路就是列竖式，然后将结果放在一个数组，最后对数组进行进位处理
    //处理完的数组判断第一个是否为0，然后进行拼接即可
    /**
     * @param {string} num1
     * @param {string} num2
     * @return {string}
     */
    var multiply = function (num1, num2) {
        if (num1 === "0" || num2 === "0") return "0";
        let result = new Array(num1.length + num2.length).fill(0);
        //列竖式相乘
        for (let i = 0; i < num1.length; i++) {
            for (let j = 0; j < num2.length; j++) {
                let temp = num1[i] * num2[j];
                result[i + j + 1] += temp;
            }
        }
        //处理进位
        for (let i = result.length - 1; i > 0; i--) {
            result[i - 1] += Math.floor(result[i] / 10);
            result[i] = result[i] % 10
        }
        //头部去零拼接
        if (result[0] === 0) result.shift();
        return result.join("")
    };

    //第四十四题链接https://leetcode-cn.com/problems/wildcard-matching/
    //第一眼看过去以为挺简单。。仔细研究发现我高估我智商了。。
    /**
     * @param {string} s
     * @param {string} p
     * @return {boolean}
     */
    var isMatch = function (s, p) {
        const sLen = s.length;
        const pLen = p.length;
        // 初始化（包括了一部分base case）
        const dp = new Array(sLen + 1);
        for (let i = 0; i < sLen + 1; i++) {
            dp[i] = new Array(pLen + 1).fill(false);
        }
        // base case
        dp[0][0] = true;
        for (let j = 1; j <= pLen; j++) {
            dp[0][j] = p[j - 1] === '*' && dp[0][j - 1];
        }
        // 迭代
        for (let i = 1; i <= sLen; i++) {
            for (let j = 1; j <= pLen; j++) {
                if (p[j - 1] === '?' || s[i - 1] === p[j - 1])
                    dp[i][j] = dp[i - 1][j - 1];
                else if (p[j - 1] === '*' && (dp[i - 1][j] || dp[i][j - 1]))
                    dp[i][j] = true;
            }
        }
        console.log(dp);
        return dp[sLen][pLen]; // 整个s串和整个p串是否匹配
        // let i = 0, pointer = 0, compare = s[0];
        // while (i < p.length) {
        //     //如果是?
        //     if (p[i] === "?") {
        //         pointer++;
        //         if (pointer === s.length) {
        //             if (i === p.length - 1) return true;
        //             for (let start = i; start < p.length; start++) {
        //                 if (p[start] !== "*") return false
        //             }
        //             return true
        //         } else {
        //             compare = s[compare];
        //         }
        //     }
        //     //如果是*
        //     else if (p[i] === "*") {
        //         if (i === s.length - 1) return true;
        //         let temp = "",
        //             start,
        //             start2;
        //         for (start = i; start < p.length; start++) {
        //             if (p[start] !== "*") {
        //                 temp = p[start];
        //                 i = start;
        //                 break;
        //             }
        //         }
        //         console.log(i, temp);
        //         if (temp === "") return true;
        //         for (start2 = pointer + 1; start2 < s.length; start2++) {
        //             if (s[start2] === temp) {
        //                 pointer = start2;
        //                 console.log(pointer)
        //                 break;
        //             }
        //             if (start2 === s.length - 1 && s[start2] !== temp) {
        //                 return false
        //             }
        //         }
        //     }
        //     //正常字母
        //     else {
        //         if (p[i] === s[pointer]) {
        //             console.log(i, pointer);
        //             if (i === p.length - 1 && pointer === s.length - 1) return true;
        //             if ((i === p.length - 1 && pointer !== s.length - 1) || (i !== p.length - 1 && pointer === s.length - 1)) return false;
        //             pointer++;
        //             i++
        //         } else {
        //             return false
        //         }
        //     }
        // }
    };
    console.log(isMatch("aaaaab", "*ab"))
</script>
</body>
</html>
