<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="data-structure.js"></script>
</head>
<body>
<script>
    //第三十一题链接https://leetcode-cn.com/problems/next-permutation/
    //这题意思需要先理解一下。。我也描述不好=）
    //首先从后向前遍历，找出第一个前数比后数小的位置，暂时记为nums[i],nums[i+1]
    //随后再从最后一位开始查找第一个比nums[i]大的，并交换位置
    //随后交换完毕后，将i位置后的序列翻转即为所求
    //即除了第一次交换位置的数之外，前后都应该为递增即为所求，没有则直接翻转
    /**
     * @param {number[]} nums
     * @return {void} Do not return anything, modify nums in-place instead.
     */
    var nextPermutation = function (nums) {
        let i = nums.length - 2;//防止i+1不存在
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--//符合条件就往前一位
        }
        //存在
        if (i >= 0) {
            let j = nums.length - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            [nums[i], nums[j]] = [nums[j], nums[i]]//交换两数
        }
        //不存在则直接翻转
        let left = i + 1, right = nums.length - 1;
        while (left < right) {
            [nums[left], nums[right]] = [nums[right], nums[left]];
            left++;
            right--
        }
        return nums
    };

    //第三十二题链接https://leetcode-cn.com/problems/longest-valid-parentheses/
    //第一反应使用堆栈进出判断，想了一下觉得有没有更简单的，提交失败N次后决定还是用栈吧。。
    /**
     * @param {string} s
     * @return {number}
     */
    var longestValidParentheses = function (s) {
        if (s.length < 2) return 0;
        let result = 0, stack = [-1];
        for (let i = 0; i < s.length; i++) {
            if (s[i] === '(') {
                stack.push(i);//注意push进去的是i，这样等会可以计算有效长度
            } else {
                //每出现一次右括号的时候都要计算一下有效长度
                stack.pop();
                if (stack.length !== 0) {
                    result = Math.max(result, i - stack[stack.length - 1]);
                } else {
                    stack.push(i)
                }
            }
        }
        return result
    };

    //第三十三题链接https://leetcode-cn.com/problems/search-in-rotated-sorted-array/
    //没有时间复杂度要求直接indexOf就行
    //要求log(N)则考虑二分查找
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var search = function (nums, target) {
        if (nums.length === 1 && nums[0] !== target) return -1;
        let start = 0,
            end = nums.length - 1;
        while (start <= end) {
            let mid = Math.ceil((start + end) / 2);
            //成立判断则输出返回
            if (nums[mid] === target) return mid;
            if (nums[start] === target) return start;
            if (nums[end] === target) return end;
            //前半部分有序
            if (nums[start] < nums[mid]) {
                //说明在前半部分，end前置
                if (nums[start] < target && target < nums[mid]) {
                    end = mid - 1;
                }
                //在后半部分，start后置
                else {
                    start = mid + 1
                }
            } else {
                if (nums[mid] < target && target < nums[end]) {
                    start = mid + 1
                } else {
                    end = mid - 1
                }
            }
        }
        return -1
    };

    //第三十四题https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/
    //二分法循环两次，一次找最小，一次找最大
    //然后发现二分和一次循环用的时间内存几乎没有区别，加了break甚至还快点==应该是测试用例的问题吧。。
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number[]}
     */
    var searchRange = function (nums, target) {
        //一次循环
        // let result=[-1,-1];
        // if(nums.length===0)return [-1,-1]
        // for(let i=0;i<nums.length;i++){
        //     if(nums[i]===target&&(nums[i-1]!==target||nums[i-1]===undefined)){
        //         result[0]=i
        //     }
        //     if(nums[i]===target&&(nums[i+1]!==target||nums[i+1]===undefined)){
        //         result[1]=i;
        //         break
        //     }
        // }
        // return result
        if (nums.length === 0) return [-1, -1];
        if (nums.length === 1) {
            return target === nums[0] ? [0, 0] : [-1, -1]
        }
        let start = 0,
            end = nums.length - 1,
            result = [-1, -1];
        //查找最小
        if (nums[0] === target) {
            result[0] = 0
        } else {
            while (start <= end) {
                let mid = Math.floor((start + end) / 2);
                if (nums[mid] < target && nums[mid + 1] === target) {
                    result[0] = mid + 1;
                    end = -1;
                } else {
                    if (nums[mid] < target) {
                        start = mid + 1;
                    } else if (nums[mid] >= target) {
                        end = mid - 1;
                    }
                }
            }
        }
        //查找最大
        start = 0;
        end = nums.length - 1;
        if (nums[end] === target) {
            result[1] = end
        } else {
            while (start <= end) {
                let mid = Math.ceil((start + end) / 2);
                if (nums[mid] > target && nums[mid - 1] === target) {
                    result[1] = mid - 1;
                    end = -1;
                } else {
                    if (nums[mid] <= target) {
                        start = mid + 1;
                    } else if (nums[mid] > target) {
                        end = mid - 1;
                    }
                }
            }
        }
        return result
    };
</script>
</body>
</html>
